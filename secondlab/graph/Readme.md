__Реализация структуры данных "**Граф**" и алгоритмов работы с ним__

1. __Цель работы__

Реализовать структуру данных Граф без использования стандартных коллекций Java.
Обеспечить поддержку основных операций добавления/удаления вершин и рёбер, а также реализацию классических алгоритмов обхода и поиска кратчайших путей. 
2. __Описание структуры данных Граф__

В реализации используется список смежности: для каждой вершины хранится список исходящих рёбер с весами. 

Каждое ребро представлено как объект класса Edge<V>, содержащий: 

    конечную вершину (to);
    вес ребра (weight).
     

Граф поддерживает: 

    ориентированные и неориентированные режимы;
    взвешенные рёбра (целочисленные веса);
    произвольный тип вершин (обобщённый параметр V).
     
Все коллекции реализованы самостоятельно без использования стандартных коллекций Java (java.util.*). 

3. __Реализованные операции__
3.1 `void addVertex(V v)`

Добавление новой вершины в граф.
Нельзя добавить null. Повторное добавление существующей вершины игнорируется.
3.2 `void addEdge(V from, V to, int weight)`

Добавление ребра между двумя вершинами с указанным весом.
Автоматически добавляет обе вершины, если они отсутствуют.
Для неориентированного графа добавляется симметричное ребро. 
3.3 `void removeVertex(V v)`

Удаление вершины и всех инцидентных ей рёбер (как входящих, так и исходящих).
Если вершина не существует — операция игнорируется.
3.4 `void removeEdge(V from, V to)`

Удаление ребра из from в to.
Для неориентированного графа также удаляется обратное ребро. 
3.5 `List<V> getAdjacent(V v)` и `DynamicArray<V> getArrayAdjacent(V v)`

    getAdjacent(V v) — возвращает список смежных вершин для заданной вершины в виде стандартного List<V> (только для соответствия ТЗ).
    getArrayAdjacent(V v) — возвращает список смежных вершин в виде собственной коллекции DynamicArray<V> (для внутреннего использования в алгоритмах).
     

Если вершина не существует или null — возвращается пустой список. 
3.6 `void dfs(V start)` и `void bfs(V start)` 

Выполняют обход графа в глубину (DFS) и в ширину (BFS) соответственно.
Результат сохраняется во внутренние поля класса и может быть получен через геттеры.
Если стартовая вершина не существует — выбрасывается исключение.

3.7 `void dijkstra(V start)` 

Реализует алгоритм Дейкстры для поиска кратчайших расстояний от стартовой вершины до всех остальных.
Поддерживает только неотрицательные веса.
Результат сохраняется во внутреннее поле и доступен через getLastDijkstraResult(). 
4. __Собственные коллекции__
4.1 `DynamicArray<T>`

Обобщённая реализация динамического массива: 

    хранение элементов в Object[];
    автоматическое удвоение ёмкости при переполнении;
    проверка границ индексов;
    поддержка операций add, get, remove, contains, clear и др.
     

4.2 `CustomHashMap<K, V>`

Хеш-таблица с открытым хешированием (цепочки): 

    начальная ёмкость — 16;
    коэффициент заполнения — 0.75;
    автоматический рехеширование при превышении порога;
    поддержка put, get, containsKey, remove, keySet.
     

4.3 `Queue<T>`

Очередь на основе кольцевого буфера: 

    начальная ёмкость — 10;
    автоматическое расширение при переполнении;
    операции enqueue, dequeue, peek.
     

5. __Ограничения__

    Не используются стандартные коллекции Java (java.util.*);
    Все коллекции реализованы самостоятельно и параметризованы;
    Вершины не могут быть null;
    Алгоритм Дейкстры требует неотрицательные веса;
    В графе не поддерживаются кратные рёбра и петли;
    Для неориентированного графа каждое ребро добавляется в обе стороны.
     

6. __Сложность операций__

    `addVertex`: O(1) (амортизированно)
    `addEdge`: O(1) (амортизированно)
    `removeVertex`: O(V + E), где V — количество вершин, E — рёбер
    `removeEdge`: O(1) (для ориентированного графа, в среднем)
    `getAdjacent`: O(deg(v)), где deg(v) — степень вершины
    `dfs`, `bfs`: O(V + E)
    `dijkstra`: O(V²) (реализация без очереди с приоритетом)
     

7. __Использование__
Запустите `java Main`
Программа предложит создать граф (ориентированный или неориентированный), а затем предоставит меню для выполнения различных операций: 

    Добавить вершину
    Добавить ребро
    Удалить вершину
    Удалить ребро
    Показать соседей вершины
    Показать все вершины
    Выполнить DFS
    Выполнить BFS
    Выполнить Дейкстру
    Выход
     

8. __Особенности реализации__

    Для соответствия ТЗ метод getAdjacent() возвращает List<V>, но внутри для всех алгоритмов используется метод getArrayAdjacent(), возвращающий собственную коллекцию DynamicArray<V>.
    Все исключительные ситуации обрабатываются через кастомную иерархию исключений (GraphException, InvalidVertexException).
    Результаты алгоритмов обхода сохраняются во внутренние поля графа и доступны через специальные геттеры.
     